<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Memoria - Buddy System</title>
    <meta name="description" content="Simulador interactivo del algoritmo Buddy System para gestión de memoria">
    <meta name="keywords" content="buddy system, memoria, simulación, algoritmos, sistemas operativos">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #memoryContainer {
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 1rem;
            overflow-x: auto;
            min-height: 400px;
        }

        .tree-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0; 
            position: relative;
            transition: width 0.4s ease-in-out, opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .tree-node.node-exiting {
            opacity: 0;
            transform: scale(0.8);
        }
        
        .node-display {
            border: 2px solid #718096;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            width: 100%; 
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 1;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            box-sizing: border-box;
            transition: background-color 0.4s ease, border-color 0.4s ease;
            overflow: hidden;
        }
        .block-info {
            font-size: 0.8rem;
            font-weight: 500;
            word-break: break-word;
            position: relative;
            z-index: 2;
        }
        .node-display.free { background-color: #c6f6d5; border-color: #48bb78; }
        .node-display.parent { background-color: #e2e8f0; border-color: #a0aec0; }
        .node-display.allocated { background-color: #e2e8f0; border-color: #4299e1; }
        
        .usage-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background-color: #90cdf4;
            transition: width 0.4s ease-in-out;
            z-index: 1;
        }

        .children-container {
            display: flex;
            justify-content: center;
            width: 100%;
            position: relative;
            margin-top: 30px;
            overflow: hidden; 
            transition: opacity 0.3s ease-in-out, max-height 0.4s ease-in-out 0.1s, margin-top 0.4s ease-in-out 0.1s;
        }

        .children-container.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }
        
        .children-container::before {
            content: ''; position: absolute; top: -15px; left: 50%;
            transform: translateX(-50%); width: 2px; height: 15px; background-color: #a0aec0;
        }
        .tree-node:not(:only-child)::before {
            content: ''; position: absolute; top: -15px; left: 0;
            width: 50%; height: 2px; background-color: #a0aec0;
        }
        .tree-node:not(:only-child)::after {
            content: ''; position: absolute; top: -15px; right: 0;
            width: 50%; height: 2px; background-color: #a0aec0;
        }
        .tree-node:first-child:last-child::before, .tree-node:first-child:last-child::after,
        .tree-node:first-child::before, .tree-node:last-child::after { display: none; }

        .deallocate-btn {
            padding: 2px 6px; font-size: 0.7rem; border-radius: 4px; background-color: #e53e3e;
            color: white; border: none; cursor: pointer; margin-top: 4px;
            transition: background-color 0.2s; position: relative; z-index: 2;
        }
        .deallocate-btn:hover { background-color: #c53030; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">

        <div class="bg-white rounded-lg shadow-xl p-6 mb-8 mt-8">
            <div class="flex flex-col md:flex-row md:items-center md:space-x-4 space-y-4 md:space-y-0">
                <div class="flex-grow">
                    <label for="processSize" class="block text-sm font-medium text-gray-700 mb-1">Tamaño del Proceso (KB):</label>
                    <input type="number" id="processSize" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Ej: 100">
                </div>
                <button id="allocateBtn" class="w-full md:w-auto bg-indigo-600 text-white font-semibold py-2 px-6 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition">Asignar Memoria</button>
                <button id="resetBtn" class="w-full md:w-auto bg-gray-500 text-white font-semibold py-2 px-6 rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 transition">Reiniciar</button>
            </div>
        </div>

        <main>
            <div class="bg-white rounded-lg shadow-xl p-6">
                <h2 class="text-xl font-semibold mb-4 text-center">Estado de la Memoria (Total: 1024 KB)</h2>
                <div id="memoryContainer" class="w-full bg-gray-50 rounded-lg border-2 border-gray-200"></div>
            </div>
        </main>
        
        <div class="bg-white rounded-lg shadow-xl p-6 mt-8">
            <h2 class="text-xl font-semibold mb-2">Registro de Eventos</h2>
            <div id="logContainer" class="h-40 bg-gray-50 rounded-md p-3 overflow-y-auto border border-gray-200 text-sm font-mono"></div>
        </div>
    </div>

    <script>
        const TOTAL_MEMORY = 1024;
        const memoryContainer = document.getElementById('memoryContainer');
        const logContainer = document.getElementById('logContainer');
        const processSizeInput = document.getElementById('processSize');
        const allocateBtn = document.getElementById('allocateBtn');
        const resetBtn = document.getElementById('resetBtn');

        let buddySystem;
        let nextProcessId = 1;
        let nextNodeId = 0; 
        
        class Node {
            constructor(tamano, direccion_inicio, padre = null) {
                this.id = nextNodeId++; 
                this.tamano = tamano;
                this.direccion_inicio = direccion_inicio;
                this.padre = padre;
                this.izquierdo = null;
                this.derecho = null;
                this.esta_dividido = false;
                this.esta_asignado = false;
                this.processId = null; 
                this.requestedSize = null;
            }
        }

        class BuddyTree {
            constructor(tamano_total) {
                if (!(tamano_total > 0 && (tamano_total & (tamano_total - 1)) === 0)) {
                    throw new Error("El tamaño total debe ser una potencia de 2.");
                }
                this.raiz = new Node(tamano_total, 0);
                this.nodos_asignados = new Map();
            }

            _nextPowerOfTwo(n) {
                if (n === 0) return 1;
                let p = 1;
                while (p < n) { p <<= 1; }
                return p;
            }

            allocate(tamano_solicitado) {
                if (tamano_solicitado <= 0) return null;
                const tamano_requerido = this._nextPowerOfTwo(tamano_solicitado);
                logEvent(`Solicitud para ${tamano_solicitado} KB. Se necesita un bloque de ${tamano_requerido} KB.`);

                if (tamano_requerido > this.raiz.tamano) {
                    return logEvent(`El tamaño requerido (${tamano_requerido}) es mayor que el total (${this.raiz.tamano}).`, 'error');
                }
                const nodo = this._findAndSplit(this.raiz, tamano_requerido);
                if (nodo) {
                    nodo.esta_asignado = true;
                    nodo.processId = `P${nextProcessId++}`;
                    nodo.requestedSize = tamano_solicitado;
                    this.nodos_asignados.set(nodo.direccion_inicio, nodo);
                    logEvent(`Asignado Proceso ${nodo.processId} (${tamano_solicitado} KB) a bloque de ${nodo.tamano} KB en Dir: ${nodo.direccion_inicio}.`, 'alloc');
                } else {
                    logEvent(`No hay espacio para un bloque de ${tamano_requerido} KB.`, 'error');
                }
                return nodo;
            }

            _findAndSplit(nodo_actual, tamano_requerido) {
                if (!nodo_actual || nodo_actual.tamano < tamano_requerido || nodo_actual.esta_asignado) return null;
                if (nodo_actual.tamano === tamano_requerido && !nodo_actual.esta_dividido) return nodo_actual;
                if (nodo_actual.tamano / 2 < tamano_requerido) return !nodo_actual.esta_dividido ? nodo_actual : null;

                if (!nodo_actual.esta_dividido) {
                    logEvent(`Dividiendo bloque de ${nodo_actual.tamano} KB en Dir: ${nodo_actual.direccion_inicio}.`, 'split');
                    nodo_actual.esta_dividido = true;
                    const mitad_tamano = nodo_actual.tamano / 2;
                    nodo_actual.izquierdo = new Node(mitad_tamano, nodo_actual.direccion_inicio, nodo_actual);
                    nodo_actual.derecho = new Node(mitad_tamano, nodo_actual.direccion_inicio + mitad_tamano, nodo_actual);
                    renderSplitAnimation(nodo_actual);
                }
                return this._findAndSplit(nodo_actual.izquierdo, tamano_requerido) || this._findAndSplit(nodo_actual.derecho, tamano_requerido);
            }

            free(direccion) {
                const nodo = this.nodos_asignados.get(direccion);
                if (!nodo) return logEvent(`Intento de liberar memoria no asignada en Dir: ${direccion}`, 'error');

                logEvent(`Liberando Proceso ${nodo.processId} (${nodo.requestedSize} KB) de bloque de ${nodo.tamano} KB en Dir: ${nodo.direccion_inicio}.`, 'free');
                nodo.esta_asignado = false;
                nodo.processId = null;
                nodo.requestedSize = null;
                this.nodos_asignados.delete(direccion);
                updateNodeDisplay(nodo);
                this._tryMerge(nodo.padre);
            }

            _tryMerge(padre) {
                if (!padre) return;
                const { izquierdo, derecho } = padre;
                if (izquierdo && !izquierdo.esta_dividido && !izquierdo.esta_asignado &&
                    derecho && !derecho.esta_dividido && !derecho.esta_asignado) {
                    renderMergeAnimation(padre);
                }
            }
        }

        function initializeMemory() {
            nextNodeId = 0;
            buddySystem = new BuddyTree(TOTAL_MEMORY);
            nextProcessId = 1;
            logContainer.innerHTML = '';
            logEvent(`Sistema inicializado con ${TOTAL_MEMORY} KB de memoria.`, 'info');
            redrawMemory();
        }

        function handleAllocation() {
            const requestedSize = parseInt(processSizeInput.value, 10);
            if (isNaN(requestedSize) || requestedSize <= 0) return logEvent('Por favor, ingrese un tamaño de proceso válido.', 'error');
            
            const allocatedNode = buddySystem.allocate(requestedSize);
            if (allocatedNode) {
                updateNodeDisplay(allocatedNode);
                updateAncestorWidths(allocatedNode);
            }
            processSizeInput.value = '';
        }

        function handleDeallocation(nodeId) {
            const nodo = findNodeById(buddySystem.raiz, nodeId);
            if(nodo) buddySystem.free(nodo.direccion_inicio);
        }
        
        function findNodeById(startNode, id) {
            if (!startNode || startNode.id === id) return startNode;
            if (startNode.esta_dividido) {
                return findNodeById(startNode.izquierdo, id) || findNodeById(startNode.derecho, id);
            }
            return null;
        }

        function redrawMemory() {
            memoryContainer.innerHTML = '';
            if (buddySystem && buddySystem.raiz) {
                memoryContainer.appendChild(createNodeElement(buddySystem.raiz));
            }
        }
        
        function renderSplitAnimation(parentNode) {
            const parentEl = document.getElementById(`tree-node-${parentNode.id}`);
            if (!parentEl) return;
            updateNodeDisplay(parentNode);
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'children-container collapsed';
            childrenContainer.append(createNodeElement(parentNode.izquierdo), createNodeElement(parentNode.derecho));
            parentEl.appendChild(childrenContainer);
            requestAnimationFrame(() => childrenContainer.classList.remove('collapsed'));
        }
        
        function renderMergeAnimation(parentNode) {
            const parentEl = document.getElementById(`tree-node-${parentNode.id}`);
            const childrenContainer = parentEl.querySelector('.children-container');
            if (!childrenContainer) return;
            logEvent(`Fusionando bloques de ${parentNode.izquierdo.tamano} KB para crear uno de ${parentNode.tamano} KB en Dir: ${parentNode.direccion_inicio}.`, 'merge');
            
            Array.from(childrenContainer.children).forEach(child => child.classList.add('node-exiting'));
            childrenContainer.classList.add('collapsed');

            setTimeout(() => {
                if (!parentNode.esta_dividido) return;
                parentNode.izquierdo = null;
                parentNode.derecho = null;
                parentNode.esta_dividido = false;
                childrenContainer.remove();
                updateNodeDisplay(parentNode);
                updateAncestorWidths(parentNode);
                buddySystem._tryMerge(parentNode.padre);
            }, 450);
        }
        
        function updateAncestorWidths(node) {
            let current = node;
            while(current) {
                const el = document.getElementById(`tree-node-${current.id}`);
                if (!el) break;
                const MIN_LEAF_WIDTH = 90;
                const NODE_SPACING = 12;
                
                let newWidth = MIN_LEAF_WIDTH;
                if (current.esta_dividido) {
                    const leftChildEl = document.getElementById(`tree-node-${current.izquierdo.id}`);
                    const rightChildEl = document.getElementById(`tree-node-${current.derecho.id}`);
                    newWidth = (leftChildEl ? parseFloat(leftChildEl.style.width) : MIN_LEAF_WIDTH) + 
                               (rightChildEl ? parseFloat(rightChildEl.style.width) : MIN_LEAF_WIDTH);
                }
                el.style.width = `${newWidth + NODE_SPACING}px`;
                current = current.padre;
            }
        }
        
        function getNodeContentConfig(node) {
            const isParent = node.esta_dividido;
            const isAllocated = !isParent && node.esta_asignado;
            const displayClass = isParent ? 'parent' : (isAllocated ? 'allocated' : 'free');
            let content = isParent ? 'Nodo Padre' : (isAllocated ? `<b>${node.processId}</b> (${node.requestedSize} KB)` : 'Libre');
            let usageBarHTML = isAllocated ? `<div class="usage-bar" style="width: ${(node.requestedSize / node.tamano) * 100}%"></div>` : '';
            let buttonHTML = isAllocated ? `<button class="deallocate-btn">Liberar</button>` : '';

            const innerHTML = `
                ${usageBarHTML}
                <div class="block-info">${node.tamano} KB<br><small>Dir: ${node.direccion_inicio}</small><br>${content}</div>
                ${buttonHTML}`;
            
            return { displayClass, innerHTML, isAllocated };
        }

        function updateNodeDisplay(node) {
            const nodeEl = document.getElementById(`tree-node-${node.id}`);
            if (!nodeEl) return;
            const nodeDisplay = nodeEl.querySelector('.node-display');
            const config = getNodeContentConfig(node);
            nodeDisplay.className = `node-display ${config.displayClass}`;
            nodeDisplay.innerHTML = config.innerHTML;
            if (config.isAllocated) {
                nodeDisplay.querySelector('.deallocate-btn').onclick = () => handleDeallocation(node.id);
            }
        }

        function createNodeElement(node) {
            const treeNode = document.createElement('div');
            treeNode.id = `tree-node-${node.id}`;
            treeNode.className = 'tree-node';
            treeNode.style.padding = `0 ${12 / 2}px`;

            const config = getNodeContentConfig(node);
            treeNode.innerHTML = `<div class="node-display ${config.displayClass}">${config.innerHTML}</div>`;
            if (config.isAllocated) {
                treeNode.querySelector('.deallocate-btn').onclick = () => handleDeallocation(node.id);
            }

            if (node.esta_dividido) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                const leftChildEl = createNodeElement(node.izquierdo);
                const rightChildEl = createNodeElement(node.derecho);
                childrenContainer.append(leftChildEl, rightChildEl);
                treeNode.appendChild(childrenContainer);
                treeNode.style.width = `${parseFloat(leftChildEl.style.width) + parseFloat(rightChildEl.style.width) + 12}px`;
            } else {
                treeNode.style.width = `${90 + 12}px`;
            }
            return treeNode;
        }

        function logEvent(message, type = 'info') {
            const config = {
                alloc: { color: 'text-blue-600', prefix: '[ASIGNAR]' },
                free: { color: 'text-red-600', prefix: '[LIBERAR]' },
                split: { color: 'text-yellow-600', prefix: '[DIVIDIR]' },
                merge: { color: 'text-green-600', prefix: '[FUSIONAR]' },
                error: { color: 'text-red-800 font-bold', prefix: '[ERROR]' },
                info: { color: 'text-gray-700', prefix: '[INFO]' }
            }[type] || { color: 'text-gray-700', prefix: '[INFO]' };
            
            const p = document.createElement('p');
            p.className = config.color;
            p.textContent = `${config.prefix} ${message}`;
            logContainer.prepend(p);
        }
        
        allocateBtn.addEventListener('click', handleAllocation);
        resetBtn.addEventListener('click', initializeMemory);
        processSizeInput.addEventListener('keyup', (e) => e.key === 'Enter' && handleAllocation());
        window.onload = initializeMemory;
    </script>
</body>
</html>


